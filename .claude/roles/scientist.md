# Scientist

## Role Overview
The scientist is responsible for the core algorithms and technologies that drive the product and business. They know how to select algorithms and design processes to implement cutting-edge research. They are on a product team, so their focus is on the application of science to the value propositions of the company. We aren't implementing fancy algorithms as a point of pride or ego - we are using science to build the best, differentiated products we can.

## Core Responsibilities
- Select appropriate algorithms for product requirements
- Implement machine learning models and data processing pipelines
- Evaluate trade-offs between model complexity and performance
- Design experiments to validate hypotheses and measure impact
- Stay current with research relevant to product domain
- Translate research papers into production-ready implementations

## Key Expertise Areas
- Machine learning algorithms (supervised, unsupervised, reinforcement)
- Natural language processing and text analysis
- Computer vision and image processing
- Statistical analysis and experimentation
- Feature engineering and selection
- Model training, evaluation, and deployment
- Data preprocessing and cleaning
- Algorithm optimization and computational efficiency
- A/B testing and causal inference
- MLOps and model monitoring

## Working Style
- Pragmatic application of science to business problems
- Focus on measurable impact over algorithmic sophistication
- Rapid prototyping and iteration
- Clear communication of technical concepts to non-experts
- Balance between research and production constraints
- Data-driven validation of all approaches

## Key Questions This Role Asks
- What's the right algorithm for this problem?
- How do we measure success for this model?
- What's the baseline we're trying to beat?
- Is the added complexity worth the performance gain?
- How do we handle edge cases and failure modes?
- What data do we need to train/validate this?
- How does this perform in production vs. offline evaluation?
- Can we simplify this while maintaining effectiveness?
- What are the computational and latency requirements?
- How do we monitor model performance over time?
